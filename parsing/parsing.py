# -*- coding: utf-8 -*-
'''
Wrapper classes around waxeye parser, for easy implementation of semantic analysis for any custom language parsed by Waxeye grammar.
Usage:
- Write LANG.wx file with Waxeye grammar of your language, LANG. Compile it to LANG_parser.py - it will contain LANGParser class.
- Subclass Context, WaxeyeTree and WaxeyeParser from this module. You'll get language-specific classes: Context, Tree and Parser
  (in some cases, Parser can be omitted and WaxeyeParser instantiated directly, without subclassing).
- Set: Tree.Parser = LANGParser, Tree.Context = Context, Parser.Tree = Tree

- Implement Context class so that it can collect all necessary language-specific data 
  when passed across the syntax Tree in WaxeyeTree.node.analyse().

- Inside Tree, define inner classes (nodes) for each non-terminal of the grammar that can be yielded by LANGParser.
  Class names must have a form of 'xNAME', where NAME is the name of the non-terminal.
  Typically, they will inherit from WaxeyeTree's "node" or "static". 
  Often, you'd like to implement own base "node" class, inheriting from the standard one.

- In nodes, override compile() method - it will be called by Tree.compile() and Parser.compile().
  Some nodes may require custom semantic analysis - override analyse() in such case.
  Implement other methods, as necessary: init(), __str__, ...

- Override Tree.compile() if you need special post-processing of the overall output generated by nodes' compile().
  Inside, call self._compile() to get the raw output.

- Use:
  >>> parser = Parser()
  >>> parser.parse(text)    -- to parse 'text' to a syntax tree (class Tree)
  >>> parser.compile(text)  -- to parse 'text' and compile the resulting tree, in one step

---
This file is part of Nifty python package. Copyright (c) 2009-2014 by Marcin Wojnarski.

Nifty is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License 
as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
Nifty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with Nifty. If not, see <http://www.gnu.org/licenses/>.
'''

import copy
from nifty.util import isstring

import waxeye           # you can use this object in client code when you need to access internal Waxeye objects


########################################################################################################################################################

class Context(object):
    """Current context of semantic analysis in Tree.analyse(), for top-down transfer of contextual data from parent to child nodes 
    and for bottom-up collection of global data from all nodes. 
    Can be modified along the way, when passed through the tree, and copied with .copy() method when local modifications must be performed. 
    """
    
    Data = None                             # class (or function that returns instantiated object) of self.data
    
    def __init__(self):
        self.data = self.Data() if self.Data else None          # global semantic information about the syntax tree
        
    def copy(self):
        "A safe - shallow - copy of Context. Global data are shared by all copies."
        return copy.copy(self)
    

class WaxeyeTree(object):
    "Contains definitions of inner classes for nodes of syntax tree. Names of nodes must have the form of 'x' followed by the name of nonterminal."
    Context = None
    Parser = None                               # parser class generated by Waxeye

    def __init__(self, waxtree):
        self.waxtree = waxtree                  # keep original AST for reference, e.g., __str__
        self.root = self.rewrite(waxtree)       # our rewritten tree built of WaxeyeTree.node subclasses

    def rewrite(self, waxnode):
        "Recursively convert a 'waxnode' of waxeye's AST tree and all its subtree into appropriate subclasses of node"
        if isstring(waxnode): return self.static(string = waxnode, tree = self) 
        if not isinstance(waxnode, waxeye.AST): return self.empty()
        
        # node is a regular non-terminal; find corresponding inner class of the tree and instantiate (this will recursively rewrite nodes down the tree)
        nodeclass = getattr(self, 'x' + waxnode.type)
        return nodeclass(waxnode, self)

#     def analyse(self):
#         "Perform semantic analysis of the tree: label nodes, collect global semantic data. Return global data of type self.contextClass.Data"
#         ctx = self.root.analyse(self.Context())                 # run top-down semantic analysis of the tree
#         self.semantics = ctx.data

    def _compile(self):
        ctx = self.root.analyse(self.Context())                     # run top-down semantic analysis of the tree
        code = self.root.compile()                                  # generate output code
        return code, ctx.data

    def compile(self): #@ReservedAssignment
        "Full compilation, with postprocessing. Can be overriden in subclasses."
        return self._compile()

    def __str__(self):
        return str(self.waxtree)
    
    ### Base node classes
    
    class node(object):
        "Generic recursive node: passes all str() and compile() requests down to children, then concatenates the returned strings."
        
        children = []                           # list of child nodes after rewriting
        pos = None                              # (start,end) positions of the substring represented by this node in the source text
        type = None                             # name of the node type as used in .wax file, <str>   @ReservedAssignment
        display = ""                            # string representation of this node for debugging purposes
        
        def init(self, waxnode, tree):
            self.children = [tree.rewrite(c) for c in waxnode.children]
            self.pos = waxnode.pos
            self.type = waxnode.type
        def __init__(self, waxnode, tree): 
            self.init(waxnode, tree)
        def __str__(self): 
            return self.display or ''.join(str(c) for c in self.children)
        
        def child(self, idx):
            "Returns child with a given index, or None if missing."
            return self.children[idx] if len(self.children) > idx else None
        
        def analyse(self, ctx):
            """Top-down semantic analysis of the tree. 'ctx' is the opening Context (pre-context) of the current node. 
            Returns closing context (post-context) of the node, which may be the same object 'ctx' (!), but doesn't have to.  
            Parent nodes shall NEVER assume that 'ctx' doesn't get modified when passed down to a child.
            If this object is going to be used again after passing to a child (even if it's only passing to another child!), a copy should be passed instead of the original."""
            for c in self.children: c.analyse(ctx.copy())
            return ctx

        def compile(self): #@ReservedAssignment
            "Top-down compilation of the tree. By default, returns concatenation of strings compiled by children nodes."
            return ''.join(c.compile() for c in self.children)

    class static(node):
        """Static string (or value of another type) that can be inferred already during initialization and then returned in str() and compile(). 
        By default, the value is made up in __init__ by merging strings from all children."""
        typecast = str              # type or method that will be applied to the parsed string to convert it to a value of appropriate type
        
        def init(self, waxnode = None, tree = None, string = None):
            children = [tree.rewrite(c) for c in waxnode.children] if waxnode else []
            self.pos = waxnode.pos if waxnode else None
            self.type = waxnode.type if waxnode else None
            string = ''.join(str(c) for c in children) or string or ''
            self.value = self.typecast(string)
        def __init__(self, waxnode = None, tree = None, string = None):
            "Additional argument 'string' is accepted, not present in base 'node'. It will be used as a node value if children produce empty string."
            self.init(waxnode, tree, string)
        def __str__(self): return str(self.value)
        def compile(self): return self.value                                                        #@ReservedAssignment
    
    class const(node):
        "A node that always generates the same output: cls.value. However, in general, it can be parsed from different substrings of input text (!)."
        value = ""
        def compile(self): return self.value                                                        #@ReservedAssignment
    
    class empty(static): pass


class WaxeyeParser(object):
    "Just a glue code that links an original waxeye parser with a custom syntax Tree."
    Tree = None                         # the syntax tree class, task-specific subclass of WaxeyeTree, that performs semantic analysis
    
    def __init__(self, treeclass = None, parserclass = None):
        "'parserclass': the original parser class generated by Waxeye."
        if treeclass: self.Tree = treeclass
        if self.Tree and not parserclass: parserclass = self.Tree.Parser
        self._waxeye = parserclass()            # instance of Waxeye's parser
        
    def waxeye(self, source):
        "Parses raw source (string) into Waxeye's AST."
        waxtree = self._waxeye.parse(source)
        if isinstance(waxtree, waxeye.ParseError): raise waxtree
        return waxtree
        
    def parse(self, source):
        "Parses raw source (string) into a syntax tree built of custom node classes (self.Tree)."
        waxtree = self.waxeye(source)
        if not self.Tree: return waxtree                # no rewriting when tree class is undefined
        return self.Tree(waxtree)
    
    def compile(self, source): #@ReservedAssignment
        "Parses the source to a tree and then compiles the tree to form output objects."
        tree = self.parse(source)
        return tree.compile()


