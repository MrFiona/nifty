# -*- coding: utf-8 -*-
'''
Wrapper classes around waxeye parser, for easy implementation of semantic analysis for any custom language parsed by Waxeye grammar.
Usage:
- Write LANG.wx file with Waxeye grammar of your language, LANG. Compile it to LANG_parser.py - it will contain LANGParser class.
- Subclass Context, WaxeyeTree and WaxeyeParser from this module. You'll get language-specific classes: Context, Tree and Parser
  (in some cases, Parser can be omitted and WaxeyeParser instantiated directly, without subclassing).
- Set: Tree.Parser = LANGParser, Tree.Context = Context, Parser.Tree = Tree

- Implement Context class so that it can collect all necessary language-specific data 
  when passed across the syntax Tree in WaxeyeTree.node.analyse().

- Inside Tree, define inner classes (nodes) for each non-terminal of the grammar that can be yielded by LANGParser.
  Class names must have a form of 'xNAME', where NAME is the name of the non-terminal.
  Typically, they will inherit from WaxeyeTree's "node" or "static". 
  Often, you'd like to implement own base "node" class, inheriting from the standard one.

- In nodes, override compile() method - it will be called by Tree.compile() and Parser.compile().
  Some nodes may require custom semantic analysis - override analyse() in such case.
  Implement other methods, as necessary: init(), __str__, ...

- Override Tree.compile() if you need special post-processing of the overall output generated by nodes' compile().
  Inside, call self._compile() to get the raw output.

- Use:
  >>> parser = Parser()
  >>> parser.parse(text)    -- to parse 'text' to a syntax tree (class Tree)
  >>> parser.compile(text)  -- to parse 'text' and compile the resulting tree, in one step

---
This file is part of Nifty python package. Copyright (c) 2009-2014 by Marcin Wojnarski.

Nifty is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License 
as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
Nifty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with Nifty. If not, see <http://www.gnu.org/licenses/>.
'''

import copy
from nifty.util import isstring

import waxeye           # you can use this object in client code when you need to access internal Waxeye objects


########################################################################################################################################################
###
###  TREE
###

class Tree(object):
    """Semantic AST. Results from rewriting the original raw AST generated by the parser.
    In contrast to raw AST, which always comprises nodes of the same type, no matter what language is parsed,
    this Tree comprises custom domain-specific nodes which implement semantic analysis specific for a given language.
    That's why rewriting from AST to Tree is done.
    Subclasses of Tree should contain inner classes named after the names of non-terminals of the grammar, 
    precedeed by leading 'x' to differentiate node classes from Tree methods and attributes.
    """
    parser  = None              # instance of AST parser class produced by parser generator
    Context = None              # Context subclass that shall be used in semantic analysis
    
    def __init__(self, source):
        """Builds Tree from 'source'. 'source' is either input text (will be parsed to raw AST and then rewritten to Tree), 
        or raw AST (only rewriting will be done).
        """
        self.ast = self.parse(source) if isstring(source) else source       # parse input text to raw AST; keep AST for future reference, e.g., __str__
        self.root = self.rewrite(self.ast)                                  # rewrite AST to a tree of Tree.node's

    def __str__(self):
        return str(self.ast)

    def parse(self, source):
        "Parses raw source (string) into a syntax tree built of custom node classes (self.Tree). Can be overridden in subclasses."
        return self.parser.parse(source)

    def rewrite(self, astroot):
        "Recursively convert a node of raw AST and all its subtree into appropriate subclasses of ``Tree.node``. Generator-specific."
        raise NotImplemented()
    
    def _rewriteNode(self, astnode):
        "Rewrites contents of a single node to corresponding Tree.node attributes: children, pos, type. Generator-specific."
        raise NotImplemented()
    
    def compile(self):                                                                                                          #@ReservedAssignment
        "Full compilation, with postprocessing. Can be overriden in subclasses."
        ctx = self.root.analyse(self.Context())                     # run top-down semantic analysis of the tree
        code = self.root.compile()                                  # generate output code
        return self.postprocess(code, ctx.data)

    def postprocess(self, code, data):
        "Override in subclasses to perform custom postprocessing of the compiled code and possibly change the return type, e.g., avoid returning 'data'."
        return code, data
        
    ### Base node classes
    
    class node(object):
        """Generic recursive node: passes all str() and compile() requests down to children, then concatenates returned strings.
        Base class for all nodes in rewritten trees.
        """
        
        children = []                           # list of child nodes after rewriting
        pos = None                              # (start,end) positions of the substring represented by this node in the source text
        type = None                             # name of non-terminal that produced this node, [str]   @ReservedAssignment
        display = ""                            # string representation of this node for debugging purposes
        
        def init(self, astnode, tree):
            "Subclasses can call self.init() when overriding __init__, instead of inconvenient call to super().__init__, difficult with inner classes."
            self.children, self.pos, self.type = tree._rewriteNode(astnode)
            
        def __init__(self, astnode, tree): 
            self.init(astnode, tree)
            
        def __str__(self): 
            return self.display or ''.join(str(c) for c in self.children)
        
        def child(self, idx):
            "Returns child with a given index, or None if missing."
            return self.children[idx] if len(self.children) > idx else None
        
        def analyse(self, ctx):
            """Top-down semantic analysis of the tree. 'ctx' is the opening Context (pre-context) of the current node. 
            Returns closing context (post-context) of the node, which may be the same object 'ctx' (!), but doesn't have to.  
            Parent nodes shall NEVER assume that 'ctx' doesn't get modified when passed down to a child.
            If this object is going to be used again after passing to a child (even if it's only passing to another child!), 
            a copy should be passed instead of the original.
            """
            for c in self.children: c.analyse(ctx.copy())
            return ctx

        def compile(self): #@ReservedAssignment
            "Top-down compilation of the tree. By default, returns concatenation of strings compiled by children nodes."
            return ''.join(c.compile() for c in self.children)

    class static(node):
        """Static string (or value of another type) that can be inferred already during initialization and then returned in str() and compile(). 
        By default, the value is made up in __init__ by merging strings from all children."""
        typecast = str              # type or method that will be applied to the parsed string to convert it to a value of appropriate type
        
        def init(self, astnode = None, tree = None, string = None):
            children, self.pos, self.type = tree._rewriteNode(astnode) if astnode else ([], None, None)
            string = ''.join(str(c) for c in children) or string or ''
            self.value = self.typecast(string)
        
        def __init__(self, astnode = None, tree = None, string = None):
            "Additional argument 'string' is accepted, not present in base 'node'. It will be used as a node value if children produce empty string."
            self.init(astnode, tree, string)
        
        def __str__(self): return str(self.value)
        def compile(self): return self.value                                                        #@ReservedAssignment
    
    class const(node):
        "A node that always generates the same output: cls.value. However, in general, it can be parsed from different substrings of input text (!)."
        value = ""
        def compile(self): return self.value                                                        #@ReservedAssignment
    
    class empty(static): pass


########################################################################################################################################################
###
###  WAXEYE tree
###

class WaxeyeTree(Tree):

    def parse(self, source):
        waxtree = self.parser.parse(source)
        if isinstance(waxtree, waxeye.ParseError): raise waxtree
        return waxtree

    def rewrite(self, waxnode):
        if isstring(waxnode): return self.static(string = waxnode, tree = self) 
        if not isinstance(waxnode, waxeye.AST): return self.empty()
        
        # node is a regular non-terminal; find corresponding inner class of the tree and instantiate (this will recursively rewrite nodes down the tree)
        nodeclass = getattr(self, 'x' + waxnode.type)
        return nodeclass(waxnode, self)

    def _rewriteNode(self, waxnode):
        children = [self.rewrite(c) for c in waxnode.children]
        return children, waxnode.pos, waxnode.type
    

########################################################################################################################################################
###
###  CONTEXT of semantic analysis
###

class Context(object):
    """Base class for classes representing current context of semantic analysis in Tree.analyse(), 
    for top-down transfer of contextual data from parent to child nodes and for bottom-up collection of global data from all nodes. 
    Can be modified along the way, when passed through the tree, and copied with .copy() method 
    when local modifications must be performed. 
    """
    
    Data = None                             # class (or function that returns instantiated object) of self.data
    
    def __init__(self):
        self.data = self.Data() if self.Data else None          # global semantic information about the syntax tree
        
    def copy(self):
        "A safe - shallow - copy of Context. Global data are shared by all copies."
        return copy.copy(self)
    
