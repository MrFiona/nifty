# -*- coding: utf-8 -*-
'''
Wrapper classes for parsers produced by parser generators: Waxeye, Parsimonious, or any other generator.
For easy implementation of semantic analysis - this is the major task that still has to be done by the programmer
after parser is generated.

Usage for Waxeye parsers (TODO: update this doc):
- Write LANG.wx file with Waxeye grammar of your language, LANG. Compile it to LANG_parser.py - it will contain LANGParser class.
- Subclass Context, WaxeyeTree and WaxeyeParser from this module. You'll get language-specific classes: Context, Tree and Parser
  (in some cases, Parser can be omitted and WaxeyeParser instantiated directly, without subclassing).
- Set: Tree.Parser = LANGParser, Tree.Context = Context, Parser.Tree = Tree

- Implement Context class so that it can collect all necessary language-specific data 
  when passed across the syntax Tree in WaxeyeTree.node.analyse().

- Inside Tree, define inner classes (nodes) for each non-terminal of the grammar that can be yielded by LANGParser.
  Class names must have a form of 'xNAME', where NAME is the name of the non-terminal.
  Typically, they will inherit from WaxeyeTree's "node" or "static". 
  Often, you'd like to implement own base "node" class, inheriting from the standard one.

- In nodes, override compile() method - it will be called by Tree.compile() and Parser.compile().
  Some nodes may require custom semantic analysis - override analyse() in such case.
  Implement other methods, as necessary: init(), __str__, ...

- Override Tree.compile() if you need special post-processing of the overall output generated by nodes' compile().
  Inside, call self._compile() to get the raw output.

- Use:
  >>> parser = Parser()
  >>> parser.parse(text)    -- to parse 'text' to a syntax tree (class Tree)
  >>> parser.compile(text)  -- to parse 'text' and compile the resulting tree, in one step

---
This file is part of Nifty python package. Copyright (c) 2009-2014 by Marcin Wojnarski.

Nifty is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License 
as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
Nifty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with Nifty. If not, see <http://www.gnu.org/licenses/>.
'''

import copy
from ..util import isstring, escape, flatten

try:
    import waxeye           # you can use this object in client code when you need to access internal Waxeye objects
except:
    pass

#try:
#    from parsimonious.nodes import Node as ParsimoniousNode
#except:
#    pass


########################################################################################################################################################
###
###  TREE
###

class Tree(object):
    """Semantic tree. Produced as a result of rewriting of the original raw AST generated by parser.
    In contrast to raw AST, which always comprises nodes of the same type, no matter what language is parsed,
    this Tree comprises custom domain-specific nodes which implement semantic analysis specific to a given language.
    That's why rewriting from AST to Tree is needed.
    Subclasses of Tree should contain inner node classes named after the names of non-terminals of the grammar, 
    precedeed by leading 'x' to differentiate node classes from Tree methods and attributes.
    Instead of inner classes, you can use methods.
    """
    parser  = None              # instance of AST parser class produced by parser generator
    #Context = None              # Context subclass that shall be used in semantic analysis
    
    text    = None              # full text of the input string fed to the parser
    ast     = None              # raw AST generated by the parser; for read access by the client
    root    = None              # root node of the final tree after rewriting
    
    _ignore_ = []               # list or space-sep. string of non-terminals that should be ignored during rewriting (pruned from the tree)
    _reduce_ = []               # list or space-sep. string of non-terminals that should be replaced with a list of their children
    
    def __init__(self, text = None, ast = None, upto = None):
        """Build Tree, either from input 'text' (will be parsed to raw AST and then rewritten to Tree), 
        or from raw AST 'ast' (only rewriting will be done).
        """
        if isstring(self._ignore_): self._ignore_ = self._ignore_.split()
        if isstring(self._reduce_): self._reduce_ = self._reduce_.split()
        self.text = text
        self.ast = self.parse(text) if text else ast                # parse input text to raw AST; keep AST for reference by the client
        if upto == "parsing": return
        self.root = self.rewrite(self.ast)                          # rewrite AST to a tree of Tree.node's

    def __str__(self):
        def info(node, depth = 0):
            prefix = '  ' * depth
            if isstring(node): return prefix + node
            return prefix + node.info(), [info(n, depth+1) for n in node.children]
        lines = info(self.root)
        return '\n'.join(flatten(lines))

    def parse(self, text):
        "Parses raw text (string) into a syntax tree built of custom node classes (self.Tree). Can be overridden in subclasses."
        return self.parser.parse(text)

    def rewrite(self, astroot):
        "Recursively convert a node of raw AST and all its subtree into appropriate subclasses of ``Tree.node``. Generator-specific."
        raise NotImplemented()
    
    def _rewriteNode(self, astnode):
        "Rewrites contents of a single node to corresponding Tree.node attributes: pos, type, children. Generator-specific."
        raise NotImplemented()
    
    def compile(self):                                                                                                          #@ReservedAssignment
        "Full compilation, with postprocessing. Can be overriden in subclasses, but usually overriding postprocess() or analyse() is enough."
        data = self.analyse()                                   # run top-down semantic analysis of the tree
        code = self.root.compile()                              # generate output code
        return self.postprocess(code, data)

    def analyse(self):
        ctx = self.root.analyse(self.Context())
        return ctx.data

    def postprocess(self, code, data):
        "Override in subclasses to perform custom postprocessing of the compiled code and possibly change the return type, e.g., avoid returning 'data'."
        return code, data
        
    ### Base node classes
    
    class node(object):
        """Generic recursive node: passes all str() and compile() requests down to children, then concatenates returned strings.
        Base class for all nodes in rewritten trees.
        """
        
        tree = None
        fulltext = None                     # full text of the input string fed to the parser; cf. text()
        pos = None                          # (start,end) positions of the substring represented by this node in 'fulltext'
        type = None                         # name of non-terminal that produced this node, [str]   @ReservedAssignment
        display = ""                        # string representation of this node for debugging purposes
        children = []                       # list of child nodes after rewriting
        
        def __init__(self, tree, astnode): 
            self.tree = tree
            self.fulltext = tree.text
            self.pos, self.type, self.children = tree._rewriteNode(astnode)
            self.init(tree, astnode)
            
        def init(self, tree, astnode):
            "Subclasses should override this method instead of __init__, so that standard initialization is still performed beforehand."
            
        def text(self):
            "The substring of source text matched by this node. None if this node was derived from other nodes during tree post-processing."
            return self.fulltext[ self.pos[0] : self.pos[1] ] if self.pos else None
    
        def info(self):
            #d = self.__dict__.copy(); del d['fulltext']
            ds = "" #" %s" % d
            return "%s%s at position %s matching: %s" % (self.infoName(), ds, self.pos, escape(str(self.text())))
        def infoName(self):
            # override in subclasses to customize info() printout
            return "<%s>" % self.type
        
        def __str__(self): 
            return self.display or ''.join(str(c) for c in self.children)
        
        def child(self, idx):
            "Returns child with a given index, or None if missing."
            return self.children[idx] if len(self.children) > idx else None
        
        def analyse(self, ctx):
            """Top-down semantic analysis of the tree. 'ctx' is the opening Context (pre-context) of the current node. 
            Returns closing context (post-context) of the node, which may be the same object 'ctx' (!), but doesn't have to.  
            Parent nodes shall NEVER assume that 'ctx' doesn't get modified when passed down to a child.
            If this object is going to be used again after passing to a child (even if it's only passing to another child!), 
            a copy should be passed instead of the original.
            """
            for c in self.children: c.analyse(ctx.copy())
            return ctx

        def compile(self): #@ReservedAssignment
            "Top-down compilation of the tree. By default, returns concatenation of strings compiled by children nodes."
            return ''.join(c.compile() for c in self.children)

    class static(node):
        """Static string (or value of another type) that can be inferred already during initialization and then returned in str() and compile(). 
        By default, the value is made up in __init__ by merging strings from all children."""
        typecast = str              # type or method that will be applied to the parsed string to convert it to a value of appropriate type
        
        def __init__(self, tree, astnode, string = None):
            "Additional argument 'string' is accepted, not present in base 'node'. It's used as a node value if children produce empty string."
            self.tree = tree
            self.fulltext = tree.text
            self.pos, self.type, children = tree._rewriteNode(astnode) if astnode else (None, None, [])
            string = ''.join(str(c) for c in children) or string or ''
            self.value = self.typecast(string)
            self.init(tree, astnode)
        
        def __str__(self): return str(self.value)
        def compile(self): return self.value                                                        #@ReservedAssignment
    
    class const(node):
        "A node that always generates the same output: cls.value. However, in general, it can be parsed from different substrings of input text (!)."
        value = ""
        def compile(self): return self.value                                                        #@ReservedAssignment
    
    class string(node):
        """Artificial node created at some intermediate stage of tree post-processing. Represents a static string 
        without precise location in the source text, typically produced from partial compilation of some other nodes."""
        value = None
        type  = "(string)"                                                                          #@ReservedAssignment
        def __init__(self, tree, value):
            self.tree = tree
            self.fulltext = tree.text
            self.value = value
        def info(self):
            return "<%s> %s" % (self.type, escape(self.value))
        
    
    class empty(static): pass


########################################################################################################################################################
###
###  WAXEYE tree
###

class WaxeyeTree(Tree):

    def parse(self, text):
        waxtree = self.parser.parse(text)
        if isinstance(waxtree, waxeye.ParseError): raise waxtree
        return waxtree

    def rewrite(self, waxnode):
        if isstring(waxnode): return self.static(self, None, waxnode) 
        if not isinstance(waxnode, waxeye.AST): return self.empty(self, None)
        
        # node is a regular non-terminal; find corresponding inner class of the tree and instantiate (this will recursively rewrite nodes down the tree)
        nodeclass = getattr(self, 'x' + waxnode.type)
        return nodeclass(self, waxnode)

    def _rewriteNode(self, waxnode):
        children = [self.rewrite(c) for c in waxnode.children]
        return waxnode.pos, waxnode.type, children
    

########################################################################################################################################################
###
###  PARSIMONIOUS tree
###

class ParsimoniousTree(Tree):

    def rewrite(self, parnode):
        def flat(): return self._rewriteNode(parnode)[-1]       # flattening: return children instead of the node
            
        name = parnode.expr_name
        if not name: return flat()                              # flatten nodes without names; static strings (labels) removed entirely
        if name in self._ignore_: return []                     # remove nodes listed in _ignore_, together with their subtrees
        if name in self._reduce_: return flat()                 # flatten nodes listed in _reduce_
        
        # find corresponding inner class of the tree and instantiate (this will recursively rewrite nodes down the tree)
        nodeclass = getattr(self, 'x' + name)
        return nodeclass(self, parnode)
    
    def _rewriteNode(self, parnode):
        children = flatten(self.rewrite(c) for c in parnode.children)
        return (parnode.start, parnode.end), parnode.expr_name, children        # pos, type, children
    

########################################################################################################################################################
###
###  CONTEXT of semantic analysis
###

class Context(object):
    """Base class for classes representing current context of semantic analysis in Tree.analyse(), 
    for top-down transfer of contextual data from parent to child nodes and for bottom-up collection of global data from all nodes. 
    Can be modified along the way, when passed through the tree, and copied with .copy() method 
    when local modifications must be performed. 
    """
    
    Data = None                             # class (or function that returns instantiated object) of self.data
    
    def __init__(self):
        self.data = self.Data() if self.Data else None          # global semantic information about the syntax tree, shared by all copies of Context
        
    def copy(self):
        "A safe - shallow - copy of Context. Global data are shared by all copies."
        return copy.copy(self)
    
