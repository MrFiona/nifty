# -*- coding: utf-8 -*-
'''
Wrapper classes around waxeye parser, for easy implementation of semantic analysis.

---
This file is part of Nifty python package. Copyright (c) 2009-2014 by Marcin Wojnarski.

Nifty is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License 
as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
Nifty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with Nifty. If not, see <http://www.gnu.org/licenses/>.
'''

import copy
from nifty.util import isstring

import waxeye           # you can use this object in client code when you need to access internal Waxeye objects


########################################################################################################################################################

class Context(object):
    """Current context of semantic analysis in Tree.analyse(), for top-down transfer of contextual data from parent to child nodes 
    and for bottom-up collection of global data from all nodes. 
    Can be modified along the way, when passed through the tree, and copied with .copy() method when local modifications must be performed. 
    """
    
    Data = None                             # class (or function that returns instantiated object) of self.data
    
    def __init__(self):
        self.data = self.Data() if self.Data else None          # global semantic information about the syntax tree
        
    def copy(self):
        "A safe - shallow - copy of Context. Global data are shared by all copies."
        return copy.copy(self)
    

class WaxeyeTree(object):
    "Contains definitions of inner classes for nodes of syntax tree. Names of nodes must have the form of 'x' followed by the name of nonterminal."
    Context = None
    Parser = None                           # the parser class generated by Waxeye

    def __init__(self, waxtree):
        self.folder = self.rewrite(waxtree)

    def rewrite(self, waxnode):
        "Recursively convert a 'waxnode' of waxeye's AST tree and all its subtree into appropriate subclasses of _node_"
        if isstring(waxnode): return self._static_(string = waxnode, tree = self) 
        if not isinstance(waxnode, waxeye.AST): return self._empty_()
        
        # node is a regular non-terminal; find corresponding inner class of the tree and instantiate (this will recursively rewrite nodes down the tree)
        nodeclass = getattr(self, 'x' + waxnode.type)
        return nodeclass(waxnode, self)

#     def analyse(self):
#         "Perform semantic analysis of the tree: label nodes, collect global semantic data. Return global data of type self.contextClass.Data"
#         ctx = self.folder.analyse(self.Context())                 # run top-down semantic analysis of the tree
#         self.semantics = ctx.data

    def _compile(self):
        ctx = self.folder.analyse(self.Context())                 # run top-down semantic analysis of the tree
        code = self.folder.compile()                              # generate output code
        return code, ctx.data

    def compile(self): #@ReservedAssignment
        "Full compilation, with postprocessing. Can be overriden in subclasses."
        return self._compile()

    
    ### Base node classes
    
    class _node_(object):
        "Generic recursive node: passes all str() and compile() requests down to children, then concatenates the returned strings."
        
        children = []                           # list of child nodes after rewriting
        pos = None                              # (start,end) positions of the substring represented by this node in the source text
        type = None                             # name of the node type as used in .wax file, <str>   @ReservedAssignment
        display = ""                            # string representation of this node for debugging purposes
        
        def init(self, waxnode, tree):
            self.children = [tree.rewrite(c) for c in waxnode.children]
            self.pos = waxnode.pos
            self.type = waxnode.type
        def __init__(self, waxnode, tree): 
            self.init(waxnode, tree)
        def __str__(self): 
            return self.display or ''.join(str(c) for c in self.children)
        
        def child(self, idx):
            "Returns child with a given index, or None if missing."
            return self.children[idx] if len(self.children) > idx else None
        
        def analyse(self, ctx):
            """Top-down semantic analysis of the tree. 'ctx' is the opening Context (pre-context) of the current node. 
            Returns closing context (post-context) of the node, which may be the same object 'ctx' (!), but doesn't have to.  
            Parent nodes shall NEVER assume that 'ctx' doesn't get modified when passed down to a child.
            If this object is going to be used again after passing to a child (even if it's only passing to another child!), a copy should be passed instead of the original."""
            for c in self.children: c.analyse(ctx.copy())
            return ctx

        def compile(self): #@ReservedAssignment
            "Top-down compilation of the tree. By default, returns concatenation of strings compiled by children nodes."
            return ''.join(c.compile() for c in self.children)

    class _static_(_node_):
        "Static string (or other value), already upon construction merges strings from all children and then returns in str() and compile()."
        typecast = str              # type or method that will be applied to the parsed string to convert it to a value of appropriate type
        
        def init(self, waxnode = None, tree = None, string = None):
            children = [tree.rewrite(c) for c in waxnode.children] if waxnode else []
            self.type = waxnode.type if waxnode else None
            string = ''.join(str(c) for c in children) or string or ''
            self.value = self.typecast(string)
        def __init__(self, waxnode = None, tree = None, string = None):
            self.init(waxnode, tree, string)
        def __str__(self): return str(self.value)
        def compile(self): return self.value   #@ReservedAssignment
    
    class _empty_(_static_): pass


class WaxeyeParser(object):
    "Just a glue code that links an original waxeye parser with a custom syntax Tree."
    Tree = None                         # the syntax tree class that performs semantic analysis
    
    def __init__(self, treeclass = None, parserclass = None):
        "'parserclass': the original parser class generated by Waxeye."
        if treeclass: self.Tree = treeclass
        if self.Tree and not parserclass: parserclass = self.Tree.Parser
        self._waxeye = parserclass()
        
    def parse(self, source):
        "Parses raw source (string) into a syntax tree built of custom node classes (self.Tree)."
        waxtree = self._waxeye.parse(source)
        if isinstance(waxtree, waxeye.ParseError): raise waxtree
        if not self.Tree: return waxtree                # no rewriting when tree class is undefined
        return self.Tree(waxtree)
    
    def compile(self, source): #@ReservedAssignment
        "Parses the source to a tree and then compiles the tree to form output objects."
        tree = self.parse(source)
        return tree.compile()


