# Grammar for web document patterns (class Pattern). Tag-oriented syntax and semantics. 
# Written in Waxeye language, see http://waxeye.org/manual.html
# 
# Compilation, in 'algo' folder: 
#   $ ./parsing/waxeye -g python pattern/ -p pattern pattern/pattern.wx
#
# This generates a pattern_parser.py file with PatternParser class.
#
# 
# ---
# This file is part of Nifty python package. Copyright (c) 2009-2014 by Marcin Wojnarski.
# 
# Nifty is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
# Nifty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with Nifty. If not, see <http://www.gnu.org/licenses/>.


document    <=  exprA

/*
	shortfill longfill justadot 
	space0 space1 spaceX
	word static staticB
	expr var optional
	tagname noname tag
*/

# TOKENS

alphanum 	<=  [a-zA-Z0-9_]								# doesn't handle Unicode characters in variable names
space       <:  :+[ \t\n\r]
tilde		<=  '~'
dot         <=  '.'
mdot        <:  '.' +'.'									# 2+ dots
special     <-  '{' | '}' | '[' | ']' | '<' | '>' | '.' | '~'

# SYNTAX & SEMANTICS

# Terminals (no recursion)

wordfill    <-  tilde						# word filler: matches a word, no tags and no spaces, [^<>\s]* lazy
shortfill   <-  :?space dot !dot :?space 	# short-range filler: all except tag symbols, [^<>]* lazy
longfill    <-  :?space mdot :?space 		# long-range filler: any characters including tags, .* lazy
justadot	<-  '{.}'						# on output prints just a regular dot, regex-escaped: \.

space0      <-  space						# maybe-space, output semantics: 0+ spaces, greedy 
space1      <-  space						# must-space, output semantics: 1+ spaces, greedy
spaceX      <-  space						# all-space, output semantics: short-filler with 1st and last char (if any) being a space
dropspace   <:  ?space						# optional leading/trailing spaces, to be omitted in AST 

word        <-  +(!special !space .)		# any word interpreted as-is, no spaces
static      <-  word *(space1 word)			# sequence of words separated by must-spaces, starts and ends with a word (not space)
wordB       <-  word						# in output regex, will allow for spaces around '=' and substitution of " with ' or the other way round 

# Non-terminals (can be recursive)

exprA       <-  dropspace *(justadot | atomic | varA | optionalA | static | tag | wordfill | longfill | shortfill | space0) dropspace		# top expression: tag-aware "all", '<' and '>' can only go together (complete tags)
exprB       <-  dropspace *(justadot | atomic | varB | optionalB | wordB | wordfill | shortfill | spaceX)									# in-tag expression

tagname     <-  word
noname      <-  dot
tag         <-  :'<' (tagname|noname) exprB ('/>' | '>')

varname    	<-  +alphanum
repeat      <-  '*' | '+' | '*+' | '++'						# possessive quantifiers are allowed, to limit backtracking during regex matching, see: www.regular-expressions.info/possessive.html
regex       <-  +(!'}' .)									# regex: all chars except '}'
vregex      <=  :'~' regex
vexprA		<=  :?space exprA
vexprB		<=  :?space exprB

varA		<-  :'{' ?repeat ?varname ?vregex ?vexprA :'}'		# ...{VAR} ...{VAR ab{CD}} ...{VAR~\w+} ...{~Ala ma \d+ koty} ...{* repeated}
varB		<-  :'{' ?repeat ?varname ?vregex ?vexprB :'}'
optionalA	<-  :'[' exprA :']'
optionalB	<-  :'[' exprB :']'
atomic      <-  :'{>' exprA :'}'								# atomic grouping, see: www.regular-expressions.info/atomic.html

/*
  Semantic equivalents:
    spaceX = shortfill
    exprA = exprB = expr
    varA = varB = var
    optionalA = optionalB = optional
*/


/* rubbish...
specialB    <-  special | '"' | "'" | '='
specialC    <-  '{' | '}' | '[' | ']' | '.'
exprC       <-  *(var | staticC | optional | space0 | longfill | shortfill)		# in-attribute-value expression
eq          <-  '='						# will have 0-spaces added around on output
attrval     <-  wordB | ('"' exprC '"') | ("'" exprC "'")
attr        <-  wordB ?(eq attrval)
*/
